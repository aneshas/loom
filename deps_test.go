package loom

import (
	"reflect"
	"testing"
)

// Generated by Claude

type testService struct {
	Name string
}

type testInterface interface {
	GetName() string
}

type testImplementation struct {
	name string
}

func (t *testImplementation) GetName() string {
	return t.name
}

func TestNewDeps(t *testing.T) {
	deps := NewDeps()
	if deps == nil {
		t.Error("NewDeps() returned nil")
	}
	if deps.services == nil {
		t.Error("NewDeps() services map is nil")
	}
}

func TestAdd_Get(t *testing.T) {
	deps := NewDeps()
	service := &testService{Name: "test"}

	Add(deps, service)

	retrieved, err := Get[*testService](deps)
	if err != nil {
		t.Errorf("Get() error = %v", err)
	}
	if retrieved.Name != "test" {
		t.Errorf("Get() = %v, want %v", retrieved.Name, "test")
	}
}

func TestAddWithLabel_GetWithLabel(t *testing.T) {
	deps := NewDeps()
	service1 := &testService{Name: "primary"}
	service2 := &testService{Name: "secondary"}

	AddWithLabel(deps, service1, "primary")
	AddWithLabel(deps, service2, "secondary")

	retrieved1, err := GetWithLabel[*testService](deps, "primary")
	if err != nil {
		t.Errorf("GetWithLabel() error = %v", err)
	}
	if retrieved1.Name != "primary" {
		t.Errorf("GetWithLabel() = %v, want %v", retrieved1.Name, "primary")
	}

	retrieved2, err := GetWithLabel[*testService](deps, "secondary")
	if err != nil {
		t.Errorf("GetWithLabel() error = %v", err)
	}
	if retrieved2.Name != "secondary" {
		t.Errorf("GetWithLabel() = %v, want %v", retrieved2.Name, "secondary")
	}
}

func TestGet_NotFound(t *testing.T) {
	deps := NewDeps()

	_, err := Get[*testService](deps)
	if err == nil {
		t.Error("Get() expected error for non-existent service, got nil")
	}
}

func TestGetWithLabel_NotFound(t *testing.T) {
	deps := NewDeps()
	service := &testService{Name: "test"}

	Add(deps, service)

	_, err := GetWithLabel[*testService](deps, "nonexistent")
	if err == nil {
		t.Error("GetWithLabel() expected error for non-existent label, got nil")
	}
}

func TestMustGet(t *testing.T) {
	deps := NewDeps()
	service := &testService{Name: "test"}

	Add(deps, service)

	retrieved := MustGet[*testService](deps)
	if retrieved.Name != "test" {
		t.Errorf("MustGet() = %v, want %v", retrieved.Name, "test")
	}
}

func TestMustGet_Panic(t *testing.T) {
	deps := NewDeps()

	defer func() {
		if r := recover(); r == nil {
			t.Error("MustGet() expected panic for non-existent service, got none")
		}
	}()

	MustGet[*testService](deps)
}

func TestMustGetWithLabel(t *testing.T) {
	deps := NewDeps()
	service := &testService{Name: "labeled"}

	AddWithLabel(deps, service, "test-label")

	retrieved := MustGetWithLabel[*testService](deps, "test-label")
	if retrieved.Name != "labeled" {
		t.Errorf("MustGetWithLabel() = %v, want %v", retrieved.Name, "labeled")
	}
}

func TestMustGetWithLabel_Panic(t *testing.T) {
	deps := NewDeps()

	defer func() {
		if r := recover(); r == nil {
			t.Error("MustGetWithLabel() expected panic for non-existent service, got none")
		}
	}()

	MustGetWithLabel[*testService](deps, "nonexistent")
}

func TestHas(t *testing.T) {
	deps := NewDeps()

	if Has[*testService](deps) {
		t.Error("Has() = true, want false for non-existent service")
	}

	service := &testService{Name: "test"}
	Add(deps, service)

	if !Has[*testService](deps) {
		t.Error("Has() = false, want true for existing service")
	}
}

func TestHasWithLabel(t *testing.T) {
	deps := NewDeps()
	service := &testService{Name: "test"}

	AddWithLabel(deps, service, "test-label")

	if !HasWithLabel[*testService](deps, "test-label") {
		t.Error("HasWithLabel() = false, want true for existing labeled service")
	}

	if HasWithLabel[*testService](deps, "nonexistent-label") {
		t.Error("HasWithLabel() = true, want false for non-existent label")
	}
}

func TestRemove(t *testing.T) {
	deps := NewDeps()
	service := &testService{Name: "test"}

	Add(deps, service)

	if !Has[*testService](deps) {
		t.Error("Service should exist before removal")
	}

	Remove[*testService](deps)

	if Has[*testService](deps) {
		t.Error("Service should not exist after removal")
	}
}

func TestRemoveWithLabel(t *testing.T) {
	deps := NewDeps()
	service1 := &testService{Name: "primary"}
	service2 := &testService{Name: "secondary"}

	AddWithLabel(deps, service1, "primary")
	AddWithLabel(deps, service2, "secondary")

	RemoveWithLabel[*testService](deps, "primary")

	if HasWithLabel[*testService](deps, "primary") {
		t.Error("Primary service should not exist after removal")
	}

	if !HasWithLabel[*testService](deps, "secondary") {
		t.Error("Secondary service should still exist after removing primary")
	}
}

func TestGetAll(t *testing.T) {
	deps := NewDeps()
	service1 := &testService{Name: "first"}
	service2 := &testService{Name: "second"}

	AddWithLabel(deps, service1, "first")
	AddWithLabel(deps, service2, "second")

	all := GetAll[*testService](deps)

	if len(all) != 2 {
		t.Errorf("GetAll() returned %d services, want 2", len(all))
	}

	if all["first"].Name != "first" {
		t.Errorf("GetAll()['first'].Name = %v, want %v", all["first"].Name, "first")
	}

	if all["second"].Name != "second" {
		t.Errorf("GetAll()['second'].Name = %v, want %v", all["second"].Name, "second")
	}
}

func TestGetAll_Empty(t *testing.T) {
	deps := NewDeps()

	all := GetAll[*testService](deps)

	if len(all) != 0 {
		t.Errorf("GetAll() returned %d services, want 0", len(all))
	}
}

func TestCount(t *testing.T) {
	deps := NewDeps()

	if Count[*testService](deps) != 0 {
		t.Errorf("Count() = %d, want 0 for empty deps", Count[*testService](deps))
	}

	service1 := &testService{Name: "first"}
	service2 := &testService{Name: "second"}

	Add(deps, service1)
	AddWithLabel(deps, service2, "labeled")

	if Count[*testService](deps) != 2 {
		t.Errorf("Count() = %d, want 2", Count[*testService](deps))
	}
}

func TestClear(t *testing.T) {
	deps := NewDeps()
	service := &testService{Name: "test"}

	Add(deps, service)

	if !Has[*testService](deps) {
		t.Error("Service should exist before clear")
	}

	deps.Clear()

	if Has[*testService](deps) {
		t.Error("Service should not exist after clear")
	}
}

func TestGetRegisteredTypes(t *testing.T) {
	deps := NewDeps()

	types := deps.GetRegisteredTypes()
	if len(types) != 0 {
		t.Errorf("GetRegisteredTypes() returned %d types, want 0 for empty deps", len(types))
	}

	service := &testService{Name: "test"}
	Add(deps, service)

	types = deps.GetRegisteredTypes()
	if len(types) != 1 {
		t.Errorf("GetRegisteredTypes() returned %d types, want 1", len(types))
	}

	expectedType := reflect.TypeOf(service)
	if types[0] != expectedType {
		t.Errorf("GetRegisteredTypes() returned type %v, want %v", types[0], expectedType)
	}
}

func TestInterface(t *testing.T) {
	deps := NewDeps()
	impl := &testImplementation{name: "implementation"}

	AddWithLabel[testInterface](deps, impl, "default")

	retrieved, err := GetWithLabel[testInterface](deps, "default")
	if err != nil {
		t.Errorf("GetWithLabel() error = %v", err)
	}

	if retrieved.GetName() != "implementation" {
		t.Errorf("retrieved.GetName() = %v, want %v", retrieved.GetName(), "implementation")
	}
}
