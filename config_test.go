package loom

import (
	"os"
	"path/filepath"
	"testing"
)

// Generated by Claude

func TestAppConfig_IsSQLite(t *testing.T) {
	tests := []struct {
		name   string
		config *AppConfig
		want   bool
	}{
		{
			name: "sqlite config",
			config: &AppConfig{
				DB: DBConfig{
					Name: "test",
				},
			},
			want: true,
		},
		{
			name: "postgres config",
			config: &AppConfig{
				DB: DBConfig{
					Host:     "localhost",
					Port:     5432,
					User:     "user",
					Password: "pass",
					Name:     "test",
				},
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.config.IsSQLite(); got != tt.want {
				t.Errorf("AppConfig.IsSQLite() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAppConfig_SQLiteDSN(t *testing.T) {
	config := &AppConfig{
		DB: DBConfig{
			Name: "testdb",
		},
	}

	dsn := config.SQLiteDSN()
	if dsn == "" {
		t.Error("SQLiteDSN() returned empty string")
	}
	if !contains(dsn, "sqlite3://") {
		t.Errorf("SQLiteDSN() = %v, want to contain 'sqlite3://'", dsn)
	}
	if !contains(dsn, "testdb.db") {
		t.Errorf("SQLiteDSN() = %v, want to contain 'testdb.db'", dsn)
	}
}

func TestAppConfig_PostgresDSN(t *testing.T) {
	config := &AppConfig{
		DB: DBConfig{
			Host:     "localhost",
			Port:     5432,
			User:     "testuser",
			Password: "testpass",
			Name:     "testdb",
		},
	}

	want := "postgres://testuser:testpass@localhost:5432/testdb?sslmode=disable"
	got := config.PostgresDSN()

	if got != want {
		t.Errorf("AppConfig.PostgresDSN() = %v, want %v", got, want)
	}
}

func TestLoadConfig(t *testing.T) {
	// Create temporary directory and config file
	tmpDir := t.TempDir()
	configData := `
db:
  name: testdb
host: localhost:8080
`

	devConfigPath := filepath.Join(tmpDir, "dev.yaml")
	err := os.WriteFile(devConfigPath, []byte(configData), 0644)
	if err != nil {
		t.Fatalf("Failed to write test config file: %v", err)
	}

	config, err := LoadConfig[AppConfig](tmpDir)
	if err != nil {
		t.Fatalf("LoadConfig() error = %v", err)
	}

	if config.DB.Name != "testdb" {
		t.Errorf("LoadConfig() DB.Name = %v, want %v", config.DB.Name, "testdb")
	}

	if config.Host != "localhost:8080" {
		t.Errorf("LoadConfig() Host = %v, want %v", config.Host, "localhost:8080")
	}
}

func TestLoadConfig_InvalidPath(t *testing.T) {
	_, err := LoadConfig[AppConfig]("/nonexistent/path")
	if err == nil {
		t.Error("LoadConfig() expected error for invalid path, got nil")
	}
}

func TestLoadConfig_InvalidYAML(t *testing.T) {
	tmpDir := t.TempDir()
	invalidYAML := `invalid: yaml: content:`

	devConfigPath := filepath.Join(tmpDir, "dev.yaml")
	err := os.WriteFile(devConfigPath, []byte(invalidYAML), 0644)
	if err != nil {
		t.Fatalf("Failed to write test config file: %v", err)
	}

	_, err = LoadConfig[AppConfig](tmpDir)
	if err == nil {
		t.Error("LoadConfig() expected error for invalid YAML, got nil")
	}
}

func TestMustLoadConfig(t *testing.T) {
	// Create temporary directory and config file
	tmpDir := t.TempDir()
	configData := `
db:
  name: testdb
host: localhost:8080
`

	devConfigPath := filepath.Join(tmpDir, "dev.yaml")
	err := os.WriteFile(devConfigPath, []byte(configData), 0644)
	if err != nil {
		t.Fatalf("Failed to write test config file: %v", err)
	}

	config := MustLoadConfig[AppConfig](tmpDir)
	if config.DB.Name != "testdb" {
		t.Errorf("MustLoadConfig() DB.Name = %v, want %v", config.DB.Name, "testdb")
	}
}

func TestMustLoadConfig_Panic(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Error("MustLoadConfig() expected panic for invalid path, got none")
		}
	}()

	MustLoadConfig[AppConfig]("/nonexistent/path")
}

// helper function for string contains check
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || (len(s) > len(substr) && containsAt(s, substr)))
}

func containsAt(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
