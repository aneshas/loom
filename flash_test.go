package loom

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/labstack/echo/v4"
)

// Generated by Claude

func TestFlashMessage_Encode(t *testing.T) {
	msg := &FlashMessage{
		Message: "Test message",
		Type:    "success",
		Params:  map[string]string{"key": "value"},
	}

	encoded := msg.Encode()
	if encoded == "" {
		t.Error("FlashMessage.Encode() returned empty string")
	}

	// Decode and verify
	decoded, err := decode(encoded)
	if err != nil {
		t.Errorf("decode() error = %v", err)
	}

	var decodedMsg FlashMessage
	err = json.Unmarshal(decoded, &decodedMsg)
	if err != nil {
		t.Errorf("json.Unmarshal() error = %v", err)
	}

	if decodedMsg.Message != msg.Message {
		t.Errorf("decoded message = %v, want %v", decodedMsg.Message, msg.Message)
	}
	if decodedMsg.Type != msg.Type {
		t.Errorf("decoded type = %v, want %v", decodedMsg.Type, msg.Type)
	}
	if decodedMsg.Params["key"] != msg.Params["key"] {
		t.Errorf("decoded params = %v, want %v", decodedMsg.Params, msg.Params)
	}
}

func TestNewMessage(t *testing.T) {
	tests := []struct {
		name    string
		msg     string
		msgType string
		kv      []string
		want    *FlashMessage
	}{
		{
			name:    "message without params",
			msg:     "test message",
			msgType: "success",
			kv:      []string{},
			want: &FlashMessage{
				Message: "test message",
				Type:    "success",
				Params:  map[string]string{},
			},
		},
		{
			name:    "message with params",
			msg:     "test message",
			msgType: "error",
			kv:      []string{"key1", "value1", "key2", "value2"},
			want: &FlashMessage{
				Message: "test message",
				Type:    "error",
				Params: map[string]string{
					"key1": "value1",
					"key2": "value2",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := newMessage(tt.msg, tt.msgType, tt.kv...)

			if got.Message != tt.want.Message {
				t.Errorf("newMessage().Message = %v, want %v", got.Message, tt.want.Message)
			}
			if got.Type != tt.want.Type {
				t.Errorf("newMessage().Type = %v, want %v", got.Type, tt.want.Type)
			}
			if len(got.Params) != len(tt.want.Params) {
				t.Errorf("newMessage().Params length = %v, want %v", len(got.Params), len(tt.want.Params))
			}
			for k, v := range tt.want.Params {
				if got.Params[k] != v {
					t.Errorf("newMessage().Params[%s] = %v, want %v", k, got.Params[k], v)
				}
			}
		})
	}
}

func TestEncodeDecode(t *testing.T) {
	testData := []byte("test data for encoding")

	encoded := encode(testData)
	if encoded == "" {
		t.Error("encode() returned empty string")
	}

	decoded, err := decode(encoded)
	if err != nil {
		t.Errorf("decode() error = %v", err)
	}

	if string(decoded) != string(testData) {
		t.Errorf("decode() = %v, want %v", string(decoded), string(testData))
	}
}

func TestFlashMiddleware(t *testing.T) {
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	// Create a flash message cookie
	flashMsg := &FlashMessage{
		Message: "test message",
		Type:    "success",
		Params:  map[string]string{},
	}
	cookie := &http.Cookie{
		Name:  flashCookieName,
		Value: flashMsg.Encode(),
	}
	req.AddCookie(cookie)

	called := false
	handler := func(c echo.Context) error {
		called = true
		// Check if flash message is in context
		flashFromCtx := c.Request().Context().Value(FlashKey{})
		if flashFromCtx == nil {
			t.Error("Flash message not found in context")
		}
		return nil
	}

	middleware := FlashMiddleware(handler)
	err := middleware(c)

	if err != nil {
		t.Errorf("FlashMiddleware() error = %v", err)
	}
	if !called {
		t.Error("Handler was not called")
	}
}

func TestFlashSet(t *testing.T) {
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	FlashSuccess(c, "success message", "key", "value")

	// Check if cookie was set
	cookies := rec.Result().Cookies()
	if len(cookies) == 0 {
		t.Error("No cookies were set")
		return
	}

	var flashCookie *http.Cookie
	for _, cookie := range cookies {
		if cookie.Name == flashCookieName {
			flashCookie = cookie
			break
		}
	}

	if flashCookie == nil {
		t.Error("Flash cookie was not set")
		return
	}

	// Decode and verify the flash message
	decoded, err := decode(flashCookie.Value)
	if err != nil {
		t.Errorf("decode() error = %v", err)
	}

	var msg FlashMessage
	err = json.Unmarshal(decoded, &msg)
	if err != nil {
		t.Errorf("json.Unmarshal() error = %v", err)
	}

	if msg.Message != "success message" {
		t.Errorf("Flash message = %v, want %v", msg.Message, "success message")
	}
	if msg.Type != "success" {
		t.Errorf("Flash type = %v, want %v", msg.Type, "success")
	}
	if msg.Params["key"] != "value" {
		t.Errorf("Flash params = %v, want %v", msg.Params["key"], "value")
	}
}

func TestFlashGet(t *testing.T) {
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	// Test with no cookie
	msg := get(c)
	if msg != nil {
		t.Error("get() expected nil when no cookie, got message")
	}

	// Test with valid cookie
	flashMsg := &FlashMessage{
		Message: "test message",
		Type:    "warning",
		Params:  map[string]string{"test": "param"},
	}
	cookie := &http.Cookie{
		Name:  flashCookieName,
		Value: flashMsg.Encode(),
	}
	req.AddCookie(cookie)

	msg = get(c)
	if msg == nil {
		t.Error("get() expected message, got nil")
		return
	}

	if msg.Message != flashMsg.Message {
		t.Errorf("get().Message = %v, want %v", msg.Message, flashMsg.Message)
	}
	if msg.Type != flashMsg.Type {
		t.Errorf("get().Type = %v, want %v", msg.Type, flashMsg.Type)
	}
}

func TestFlashSuccessNow(t *testing.T) {
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	FlashSuccessNow(c, "success now", "key", "value")

	// Check if message is in context
	flashFromCtx := c.Request().Context().Value(FlashKey{})
	if flashFromCtx == nil {
		t.Error("Flash message not found in context after FlashSuccessNow")
		return
	}

	msg, ok := flashFromCtx.(*FlashMessage)
	if !ok {
		t.Error("Flash message in context is not of correct type")
		return
	}

	if msg.Message != "success now" {
		t.Errorf("Flash message = %v, want %v", msg.Message, "success now")
	}
	if msg.Type != "success" {
		t.Errorf("Flash type = %v, want %v", msg.Type, "success")
	}
}
